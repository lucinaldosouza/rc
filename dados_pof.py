# -*- coding: utf-8 -*-
"""Dados_pof.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jNou5WQshH_yu2No90hGgQdKPVWLncqY
"""

#!pip install basedosdados # rode para instalar no Python/Jupyter
!pip install pandas==1.5.3 numpy==1.23.5

!pip uninstall -y shapely pygeos geopandas
# Install specific versions of shapely, pygeos, and geopandas known to be compatible
!pip install shapely==1.8.5.post1 pygeos==0.12.0 geopandas==0.10.2
# Upgrade google-cloud-aiplatform
!pip install -U google-cloud-aiplatform

"""POF 4 - Questionário de Despesa Individual - neste questionário foram registradas as despesas com bens e serviços, em geral de utilização pessoal, ou seja, aquelas não constantes do POF 2 e do POF 3, tais como: vestuário, produtos farmacêuticos, alimentação fora do domicílio, veículos, transportes, viagens esporádicas, vestuário, comunicação, etc.

POF 2 - Questionário de Despesa Coletiva - neste questionário foram registradas as despesas com bens e serviços que, em geral, servem ao domicílio e a todos os moradores. As despesas com serviços ao domicílio (energia elétrica, gás, telefone, etc.); despesas com aluguel, condomínio; aquisições de produtos eletrodomésticos; despesas com artigos de limpeza e despesas com pequenos reparos ou manutenção do domicílio; despesas com empregados domésticos e informações das características do inventário dos bens duráveis.
"""

!pip install basedosdados
import basedosdados as bd

# Para carregar o dado direto no pandas (despesa individual)
df_ind = bd.read_table(dataset_id='br_ibge_pof',
table_id='despesa_individual_2017',
billing_project_id="pof-python-412923")

# Para carregar o dado direto no pandas (despesa coletiva)
df_col = bd.read_table(dataset_id='br_ibge_pof',
table_id='despesa_coletiva_2017',
billing_project_id="pof-python-412923")

# Para carregar o dado direto no pandas (caderneta coletiva)
df_cad = bd.read_table(dataset_id='br_ibge_pof',
table_id='caderneta_coletiva_2017',
billing_project_id="pof-python-412923")

# Para carregar o dado direto no pandas (moradores)
df_mor = bd.read_table('br_ibge_pof', 'morador_2017', billing_project_id='pof-python-412923')
# Contar número de pessoas por UC
df_uc_pessoas = df_mor.groupby('id_unidade_consumo').size().reset_index(name='num_pessoas')

import pandas as pd

# Para ver o nome de todas as colunas
#print(df.columns)

#print(df_cad.columns)
print(df_ind.columns)

# variáveis para comparação no modelo: Riqueza, Rendimentos, Consumo e Poupança
# variáveis da POF: V8000_deflacionado (BRL) e renda_total

"""# Estatísticas descritivas

## Estatísticas para dados individuais: *valores individuais possivelmente estão mais sujeitos à restrição do consumo de subsistência*
"""

df_ind

"""## Cálculo do consumo per capita sem bens duráveis

O quadros dos duraveis são os números (V9001) 14, 15, 16, 17, 18, 51 e compreedem

Quadro	Conteúdo típico	Durável? \\
14	Eletrodomésticos, eletrônicos (fogão, geladeira, TV, notebook etc) \\
15	Eletrônicos “premium” (televisores LED/LCD, som, notebooks, tablets etc) \\
16	Utensílios domésticos grandes (fogão a gás/lenha, filtros, máquinas de costura etc) \\
17	Móveis (sofá, poltrona, cama, armários, estantes etc) \\
18	Têxteis e artigos de decoração duráveis (tapetes, cortinas, persianas, almofadas etc) \\
51	Veículos e afins (automóveis, motos, bicicletas, quadriciclos etc) \\
4700101 e 4700201 Valores de compra de aquisição de imóveis e terrenos
"""

quadros_duraveis = ['14', '15', '16', '17', '18', '51']
V9001_duraveis = ['4700101', '4700201', '5100101', '5100201', '5100301', '5100401']

type(quadros_duraveis[0])

"""### Aplicando o filtro de bens duráveis"""

# 1) Padronize as duas colunas como string SEM espaços / zeros-à-esquerda
df_ind["id_quadro"] = (
    df_ind["id_quadro"].astype(str).str.strip().str.lstrip("0")
)
df_ind["V9001"] = (
    df_ind["V9001"].astype(str).str.strip().str.lstrip("0")
)

# 2) Conjuntos de códigos dos bens duráveis
quadros_duraveis = {"14","15","16","17","18","51"}
V9001_duraveis   = {
    "4700101","4700201",
    "5100101","5100201","5100301","5100401","5101101"
}

# 3) Monte UMA máscara booleana combinada
mask_duravel = (
    df_ind["id_quadro"].isin(quadros_duraveis) |
    df_ind["V9001"].isin(V9001_duraveis)
)

# 4) Aplique o filtro uma única vez e guarde numa NOVA variável
df_ind_sdur = df_ind.loc[~mask_duravel].copy()

# 5) Verificar se o quadro 51 (ou qualquer código de V9001 durável) escapou
print("'51' presente?", "51" in df_ind_sdur["id_quadro"].unique())
print(set(V9001_duraveis) & set(df_ind_sdur["V9001"].unique()))

# Quais id_quadro exatamente estão escapando?
df_ind_sdur[df_ind_sdur['id_quadro'].str.contains('51', regex=False)]['id_quadro'].unique()

# Quais caracteres aparecem em volta?
(df_ind_sdur['id_quadro']
 .loc[df_ind_sdur['id_quadro'].str.contains('51')]
 .apply(lambda x: f"'{x}'"))    # mostra aspas para ver espaços

df_ind_sdur['id_quadro'].unique()

(df_ind_sdur['V8000_deflacionado'] > 200000).count()
#df_ind_sdur['V8000_deflacionado'].value_counts().sort_index()
# Para visualizar
df_ind_sdur[df_ind_sdur['V8000_deflacionado'] > 50000]['V9001'].value_counts()

df_ind_sdur[df_ind_sdur['V8000_deflacionado'] < 1]['V9001'].value_counts()

# Verificando consumo per capita do consumo individual
df_ind_sdur_sum = df_ind_sdur.groupby('id_unidade_consumo').agg({
    'V8000_deflacionado': 'sum',
    'peso_final': 'first'  # se o peso é por UC
})

# Merge na mesma tabela de n de pessoas por UC
df_ind_sdur_merge = df_ind_sdur_sum.merge(df_uc_pessoas, on='id_unidade_consumo')

# Calcular consumo per capita
df_ind_sdur_merge['consumo_per_capita'] = df_ind_sdur_merge['V8000_deflacionado'] / df_ind_sdur_merge['num_pessoas']

"""### Para o consumo coletivo"""

# 1) Padronize as duas colunas como string SEM espaços / zeros-à-esquerda
df_col["id_quadro"] = (
    df_col["id_quadro"].astype(str).str.strip().str.lstrip("0")
)
df_col["V9001"] = (
    df_col["V9001"].astype(str).str.strip().str.lstrip("0")
)

# 2) Conjuntos de códigos dos bens duráveis
quadros_duraveis = {"14","15","16","17","18","51"}
V9001_duraveis   = {
    "4700101","4700201",
    "5100101","5100201","5100301","5100401","5101101", "1200101", "1200201", "1199901", "1000301", "1000701", "1102402", "1102401", "899901"
}

# 3) Monte UMA máscara booleana combinada
mask_duravel = (
    df_col["id_quadro"].isin(quadros_duraveis) |
    df_col["V9001"].isin(V9001_duraveis)
)

# 4) Aplique o filtro uma única vez e guarde numa NOVA variável
df_col_sdur = df_col.loc[~mask_duravel].copy()

# 5) Verificar se o quadro 51 (ou qualquer código de V9001 durável) escapou
print("'51' presente?", "51" in df_ind_sdur["id_quadro"].unique())
print(set(V9001_duraveis) & set(df_ind_sdur["V9001"].unique()))

df_col_sdur['id_quadro'].unique()

df_col_sdur[df_col_sdur['V8000_deflacionado'] > 500000]

df_col_sdur[df_col_sdur['id_unidade_consumo'] == '4300001131501']

# Verificando consumo per capita do consumo coletivo
df_col_sdur_sum = df_col_sdur.groupby('id_unidade_consumo').agg({
    'V8000_deflacionado': 'sum',
    'peso_final': 'first'  # se o peso é por UC
})

df_col_sdur_merge = df_col_sdur_sum.merge(df_uc_pessoas, on='id_unidade_consumo')

df_col_sdur_merge['consumo_per_capita'] = df_col_sdur_merge['V8000_deflacionado'] / df_col_sdur_merge['num_pessoas']

df_col_sdur_merge[df_col_sdur_merge['V8000_deflacionado'] > 300000]

(df_col_sdur['V8000_deflacionado'] > 200000).count()
#df_ind_sdur['V8000_deflacionado'].value_counts().sort_index()
# Para visualizar
df_col_sdur[df_col_sdur['V8000_deflacionado'] > 50000]['V9001'].value_counts()
df_ind_sdur[df_ind_sdur['V8000_deflacionado'] > 500000]

df_col_sdur_merge['consumo_per_capita'].describe()

# Juntando os dois dataframes
df_merge_sd = df_ind_sdur_merge[['id_unidade_consumo', 'num_pessoas', 'consumo_per_capita']].merge(
    df_col_sdur_merge[['id_unidade_consumo', 'consumo_per_capita']],
    on='id_unidade_consumo',
    suffixes=('_ind', '_col')  # sufixos para diferenciar as duas colunas
)

# Criar nova coluna de consumo per capita total (individual + coletivo)
df_merge_sd['consumo_per_capita_total'] = (
    df_merge_sd['consumo_per_capita_ind'] + df_merge_sd['consumo_per_capita_col']
)

df_merge_sd.describe()

"""### Sem bens duráveis e sem funcionários públicos"""

# Para carregar o dado direto no pandas (tipo do trabalho)
df_func = bd.read_table(dataset_id='br_ibge_pof',
table_id='rendimento_trabalho_2017',
billing_project_id="pof-python-412923")

# Filtrando UCs que não tem funcionário público
# Cria um indicador: se há funcionário público na UC
df_sfp_sd = df_func[df_func['V5302'] == '4']
ucs_com_funcionario_publico = df_sfp_sd['id_unidade_consumo'].unique()

# Remove essas UCs do df_merge_final
df_merge_sd_sfp = df_merge_sd[~df_merge_sd['id_unidade_consumo'].isin(ucs_com_funcionario_publico)]

df_merge_sd_sfp.describe()

"""### Estatísticas"""

df_merge_sd_sfp['consumo_per_capita_total'].describe()
# média 1712.057861 para 1.240978482550465
# então cmin = 1.3751372838375977 -> 0.0009967629124395289

# 1712.057861 ---- 1.240978482550465
#     x       ---- 1.3751372838375977
# 1.240978482550465 * x = 2354.3145967483474
# x = 1897.1437698982086 \approx 1897.14


# 2362.64 / 1.24 = 1905.35

# cmin convertido para reais = 1712.057861
 (df_merge_sd_sfp['consumo_per_capita_total'] < 1897.14).mean()

# Histograma
import matplotlib.pyplot as plt
plt.figure(figsize=(10, 6))
plt.hist(df_merge_sd_sfp['consumo_per_capita_total'], bins=100, edgecolor='black')
plt.title('Distribuição do Consumo Per Capita Total')
plt.xlabel('Consumo per capita (R$)')
plt.ylabel('Frequência')
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt

# teste por faixa manual
faixas = pd.cut(df_merge_sd_sfp['consumo_per_capita_total'],
                bins=[0, 500, 1000, 1500, 2000, 2500, 3000, 3500, 5000, 10000],
                labels=['0-500', '500-1000', '1000-1500', '1500-2000', '2000-2500', '3000-3500','3500-5000', '5000-10000','10000+'])

distrib_faixas = faixas.value_counts().sort_index()
print(distrib_faixas)

distrib_faixas.plot(kind='bar', figsize=(8, 5), color='skyblue', edgecolor='black')
plt.title('Distribuição de Unidades de Consumo por Faixa de Consumo Per Capita Total')
plt.xlabel('Faixa de Consumo per capita (R$)')
plt.ylabel('Número de UCs')
plt.grid(True)
plt.show()

import numpy as np

def share_distribution_unweighted(x, p_top=0.10, p_bottom=0.50):
    """
    Calcula os shares de consumo do top p% e bottom q% sem ponderação
    """
    x_sorted = np.sort(x)
    n = len(x_sorted)
    total = np.sum(x_sorted)

    # Índices
    n_top = int(np.floor(p_top * n))
    n_bottom = int(np.floor(p_bottom * n))

    # Top p%
    top_share = np.sum(x_sorted[-n_top:]) / total

    # Bottom q%
    bottom_share = np.sum(x_sorted[:n_bottom]) / total

    return top_share, bottom_share


x = df_merge_sd_sfp['consumo_per_capita_total'].values

# Top 10% e Bottom 50%
top10, bottom50 = share_distribution_unweighted(x, p_top=0.10, p_bottom=0.50)
print(f"Top 10% consome {top10:.2%} da despesa total")
print(f"Bottom 50% consome {bottom50:.2%} da despesa total")

# Top 1% e Bottom 10%
top1, bottom10 = share_distribution_unweighted(x, p_top=0.01, p_bottom=0.10)
print(f"Top 1% consome {top1:.2%} da despesa total")
print(f"Bottom 10% consome {bottom10:.2%} da despesa total")

"""## CONSUMO INDIVIDUAL

### Ajeitar
"""

# Verificando consumo per capita do consumo individual
df_ind_sum = df_ind.groupby('id_unidade_consumo').agg({
    'V8000_deflacionado': 'sum',
    'peso_final': 'first'  # se o peso é por UC
})

# df_ind_sum2 = df_ind.groupby('id_unidade_consumo')['V8000_deflacionado'].sum().reset_index(name='consumo_uc')

# Merge na mesma tabela de n de pessoas por UC
df_merge2 = df_ind_sum.merge(df_uc_pessoas, on='id_unidade_consumo')

# Calcular consumo per capita
df_merge2['consumo_per_capita'] = df_merge2['V8000_deflacionado'] / df_merge2['num_pessoas']


media_ponderada21 = (df_merge2['V8000_deflacionado'] * df_merge2['peso_final']).sum() / df_merge2['peso_final'].sum()
media_ponderada2 = df_merge2['consumo_per_capita'].mean()
print(media_ponderada2)

# Verificando consumo per capita do consumo coletivo
df_col_sum = df_col.groupby('id_unidade_consumo').agg({
    'V8000_deflacionado': 'sum',
    'peso_final': 'first'  # se o peso é por UC
})

df_merge3 = df_col_sum.merge(df_uc_pessoas, on='id_unidade_consumo')

# Calcular consumo per capita
df_merge3['consumo_per_capita'] = df_merge3['V8000_deflacionado'] / df_merge3['num_pessoas']


media_ponderada2 = (df_merge2['V8000_deflacionado'] * df_merge2['peso_final']).sum() / df_merge2['peso_final'].sum()
media_ponderada3 = df_merge3['consumo_per_capita'].mean()
print(media_ponderada3)

# Juntando os dois dataframes
df_merge_final = df_merge2[['id_unidade_consumo', 'num_pessoas', 'consumo_per_capita']].merge(
    df_merge3[['id_unidade_consumo', 'consumo_per_capita']],
    on='id_unidade_consumo',
    suffixes=('_ind', '_col')  # sufixos para diferenciar as duas colunas
)

# Criar nova coluna de consumo per capita total (individual + coletivo)
df_merge_final['consumo_per_capita_total'] = (
    df_merge_final['consumo_per_capita_ind'] + df_merge_final['consumo_per_capita_col']
)

# estatísticas descritivas
df_merge_final['consumo_per_capita_total'].describe()

df_merge_final
avg_con = 3947.13
bottommean = (df_merge_final['consumo_per_capita_total'] < avg_con).mean()
print(bottommean)

df_merge_final.tail()

# Histograma
import matplotlib.pyplot as plt
plt.figure(figsize=(10, 6))
plt.hist(df_merge_final['consumo_per_capita_total'], bins=100, edgecolor='black')
plt.title('Distribuição do Consumo Per Capita Total')
plt.xlabel('Consumo per capita (R$)')
plt.ylabel('Frequência')
plt.grid(True)
plt.show()

# box-plot
plt.figure(figsize=(8, 4))
plt.boxplot(df_merge_final['consumo_per_capita_total'], vert=False)
plt.title('Boxplot do Consumo Per Capita Total')
plt.xlabel('Consumo per capita (R$)')
plt.grid(True)
plt.show()


import seaborn as sns

plt.figure(figsize=(10, 6))
sns.kdeplot(df_merge_final['consumo_per_capita_total'], shade=True)
plt.title('Distribuição de Densidade - Consumo Per Capita Total')
plt.xlabel('Consumo per capita (R$)')
plt.ylabel('Densidade')
plt.grid(True)
plt.show()

# teste por faixa manual
faixas = pd.cut(df_merge_final['consumo_per_capita_total'],
                bins=[0, 500, 1000, 1500, 2000, 3000, 5000, 10000],
                labels=['0-500', '500-1000', '1000-1500', '1500-2000', '2000-3000', '3000-5000', '5000+'])

distrib_faixas = faixas.value_counts().sort_index()
print(distrib_faixas)

distrib_faixas.plot(kind='bar', figsize=(8, 5), color='skyblue', edgecolor='black')
plt.title('Distribuição de Unidades de Consumo por Faixa de Consumo Per Capita Total')
plt.xlabel('Faixa de Consumo per capita (R$)')
plt.ylabel('Número de UCs')
plt.grid(True)
plt.show()

"""### Removendo Outliers"""

# Utilizando intervalo interquartil

Q1 = df_merge_final['consumo_per_capita_total'].quantile(0.25)
Q3 = df_merge_final['consumo_per_capita_total'].quantile(0.75)
IQR = Q3 - Q1

limite_inferior = Q1 - 1.5 * IQR
limite_superior = Q3 + 1.5 * IQR

# Filtrando os dados dentro dos limites
df_sem_outliers = df_merge_final[
    (df_merge_final['consumo_per_capita_total'] >= limite_inferior) &
    (df_merge_final['consumo_per_capita_total'] <= limite_superior)
]

df_sem_outliers['consumo_per_capita_total'].describe()

import seaborn as sns

plt.figure(figsize=(10, 6))
sns.kdeplot(df_sem_outliers['consumo_per_capita_total'], shade=True)
plt.title('Distribuição de Densidade - Consumo Per Capita Total')
plt.xlabel('Consumo per capita (R$)')
plt.ylabel('Densidade')
plt.grid(True)
plt.show()

# Usando limites por perecntis
p1 = df_merge_final['consumo_per_capita_total'].quantile(0.01)
p99 = df_merge_final['consumo_per_capita_total'].quantile(0.99)

df_sem_outliers = df_merge_final[
    (df_merge_final['consumo_per_capita_total'] >= p1) &
    (df_merge_final['consumo_per_capita_total'] <= p99)
]

df_sem_outliers['consumo_per_capita_total'].describe()

import seaborn as sns

plt.figure(figsize=(10, 6))
sns.kdeplot(df_sem_outliers['consumo_per_capita_total'], shade=True)
plt.title('Distribuição de Densidade - Consumo Per Capita Total')
plt.xlabel('Consumo per capita (R$)')
plt.ylabel('Densidade')
plt.grid(True)
plt.show()

"""### Cálculo dos momentos"""

df_merge_final['consumo_per_capita_total'].quantile([.1, .5, .9])

cv = df_merge_final['consumo_per_capita_total'].std() / df_merge_final['consumo_per_capita_total'].mean()
print(cv)

from scipy.stats import skew, kurtosis
skew(df_merge_final['consumo_per_capita_total'])
kurtosis(df_merge_final['consumo_per_capita_total'])

"""### Excluindo funcionários públicos

"""

# Para carregar o dado direto no pandas (despesa coletiva)
df_func = bd.read_table(dataset_id='br_ibge_pof',
table_id='rendimento_trabalho_2017',
billing_project_id="pof-python-412923")

print(df_func.columns)

# Contagem por função
df_func['V5302'].value_counts().sort_index()

df_func[df_func['V5302'] == '4']

# Filtrando UCs que não tem funcionário público
# Cria um indicador: se há funcionário público na UC
df_func_publico = df_func[df_func['V5302'] == '4']
ucs_com_funcionario_publico = df_func_publico['id_unidade_consumo'].unique()

# Remove essas UCs do df_merge_final
df_merge_sem_fp = df_merge_final[~df_merge_final['id_unidade_consumo'].isin(ucs_com_funcionario_publico)]

print(ucs_com_funcionario_publico)

df_merge_sem_fp
df_merge_sem_fp['consumo_per_capita_total'].describe()

df_merge_sem_fp.columns

import seaborn as sns

plt.figure(figsize=(10, 6))
sns.kdeplot(df_merge_sem_fp['consumo_per_capita_total'], shade=True)
plt.title('Distribuição de Densidade - Consumo Per Capita Total')
plt.xlabel('Consumo per capita (R$)')
plt.ylabel('Densidade')
plt.grid(True)
plt.show()

import numpy as np

def share_distribution_unweighted(x, p_top=0.10, p_bottom=0.50):
    """
    Calcula os shares de consumo do top p% e bottom q% sem ponderação
    """
    x_sorted = np.sort(x)
    n = len(x_sorted)
    total = np.sum(x_sorted)

    # Índices
    n_top = int(np.floor(p_top * n))
    n_bottom = int(np.floor(p_bottom * n))

    # Top p%
    top_share = np.sum(x_sorted[-n_top:]) / total

    # Bottom q%
    bottom_share = np.sum(x_sorted[:n_bottom]) / total

    return top_share, bottom_share


x = df_merge_final['consumo_per_capita_total'].values

# Top 10% e Bottom 50%
top10, bottom50 = share_distribution_unweighted(x, p_top=0.10, p_bottom=0.50)
print(f"Top 10% consome {top10:.2%} da despesa total")
print(f"Bottom 50% consome {bottom50:.2%} da despesa total")

# Top 1% e Bottom 10%
top1, bottom10 = share_distribution_unweighted(x, p_top=0.01, p_bottom=0.10)
print(f"Top 1% consome {top1:.2%} da despesa total")
print(f"Bottom 10% consome {bottom10:.2%} da despesa total")

df_merge_sem_fp['consumo_per_capita_total'].values

# Gráfico sem FP

import seaborn as sns

plt.figure(figsize=(10, 6))
sns.kdeplot(df_merge_sem_fp['consumo_per_capita_total'], shade=True)
plt.title('Distribuição de Densidade - Consumo Per Capita Total')
plt.xlabel('Consumo per capita (R$)')
plt.ylabel('Densidade')
plt.grid(True)
plt.show()

df_merge2

# Calcular consumo total da UC
df_ind_sum = df_ind.groupby('id_unidade_consumo')['V8000_deflacionado'].sum().reset_index(name='consumo_uc')


# Contar número de pessoas por UC
df_mor = bd.read_table('br_ibge_pof', 'morador_2017', billing_project_id='pof-python-412923')
df_uc_pessoas = df_mor.groupby('id_unidade_consumo').size().reset_index(name='num_pessoas')

# Juntar tabelas
df_merge = df_ind_sum.merge(df_uc_pessoas, on='id_unidade_consumo')

# Calcular consumo per capita
df_merge['consumo_per_capita'] = df_merge['consumo_uc'] / df_merge['num_pessoas']



# Tentando com pesos amostrais
df_total_uc = df_ind.groupby('id_unidade_consumo').agg({
    'V8000_deflacionado': 'sum',
    'peso_final': 'first'  # se o peso é por UC
})

media_ponderada = (df_total_uc['V8000_deflacionado'] * df_total_uc['peso_final']).sum() / df_total_uc['peso_final'].sum()
print(media_ponderada)

media_per_capita_ponderada = (
    df_merge['consumo_per_capita'] * df_merge['peso_final']
).sum() / df_final['peso_final'].sum()

df_merge

# 2. Somar o consumo mensal deflacionado por UC
df_consumo_uc = df_ind.groupby('id_unidade_consumo').agg({
    'V8000_deflacionado': 'sum',
    'peso_final': 'first'  # peso da UC (mesmo para todas as linhas)
}).reset_index()
df_consumo_uc.rename(columns={'V8000_deflacionado': 'consumo_uc'}, inplace=True)

# 3. Carregar dados de moradores para contar pessoas por UC
df_mor = bd.read_table(
    dataset_id='br_ibge_pof',
    table_id='morador_2017',
    billing_project_id='pof-python-412923',
    columns=['id_unidade_consumo']
)

# Contar número de pessoas por unidade de consumo
df_pessoas_uc = df_mor.groupby('id_unidade_consumo').size().reset_index(name='num_pessoas')

# 4. Juntar consumo com número de pessoas
df_final = df_consumo_uc.merge(df_pessoas_uc, on='id_unidade_consumo')

# 5. Calcular consumo per capita
df_final['consumo_per_capita'] = df_final['consumo_uc'] / df_final['num_pessoas']

# 6. Calcular média ponderada pelo peso final
media_per_capita_ponderada = (
    df_final['consumo_per_capita'] * df_final['peso_final']
).sum() / df_final['peso_final'].sum()

print(f"Consumo médio per capita mensal (ponderado): R$ {media_per_capita_ponderada:.2f}")

df_merge.consumo_per_capita.mean()

# Incluindo o peso final
# Carregar a tabela com o peso
df_uc = bd.read_table('br_ibge_pof', 'unidade_de_consumo_2017', billing_project_id='pof-python-412923')
df_uc_peso = df_uc[['id_unidade_consumo', 'peso_final']]

# Juntar o peso
df_merge = df_merge.merge(df_uc_peso, on='id_unidade_consumo')

# Calcular média ponderada do consumo per capita
media_ponderada = (df_merge['consumo_per_capita'] * df_merge['PESO_FINAL']).sum() / df_merge['PESO_FINAL'].sum()
print(f"Média nacional do consumo per capita: R$ {media_ponderada:.2f}")

# Tentando com pesos amostrais
df_total_uc = df_ind.groupby('id_unidade_consumo').agg({
    'V8000_deflacionado': 'sum',
    'peso_final': 'first'  # se o peso é por UC
})

media_ponderada = (df_total_uc['V8000_deflacionado'] * df_total_uc['peso_final']).sum() / df_total_uc['peso_final'].sum()
print(media_ponderada)

# Somar todas as despesas da unidade
df_total_uc_ind = df_ind.groupby('id_unidade_consumo')['V8000_deflacionado'].sum()
print(df_total_uc_ind)

# Agora sim, a média de consumo mensal por unidade
media_consumo_uc = df_total_uc_ind.mean()
print(media_consumo_uc)

#df_estatisticas = estagr_con_ind[['mean', '25%', '50%', '75%']]
estagr_con_ind = df_ind.groupby('id_unidade_consumo')['V8000_deflacionado'].mean()
estagr_con_ind

estagr_con_ind.describe()

media_consumo = 198.060908

# Proporção de unidades de consumo com gasto médio individual abaixo da média
# (média da despesa individual por unidade de consumo)
proporcao_abaixo_media = (estagr_con_ind < media_consumo).mean()
proporcao_abaixo_media

"""### RENDA INDIVIDUAL"""

estagr_ren_ind = df_ind.groupby('id_unidade_consumo')['renda_total'].mean()
estagr_ren_ind

estagr_ren_ind.describe()

# Juntando as duas séries
df_medias = pd.merge(estagr_con_ind, estagr_ren_ind, on='id_unidade_consumo')
df_medias

"""### Inserindo poupança"""

# Cria a terceira coluna fazendo a subtração
df_medias['poupanca'] = df_medias['renda_total'] - df_medias['V8000_deflacionado']
df_medias

from matplotlib import pyplot as plt
df_medias.plot(kind='scatter', x='V8000_deflacionado', y='renda_total', s=32, alpha=.8)
plt.gca().spines[['top', 'right',]].set_visible(False)

from matplotlib import pyplot as plt
df_medias.plot(kind='scatter', x='poupanca', y='renda_total', s=32, alpha=.8)
plt.gca().spines[['top', 'right',]].set_visible(False)

df_medias.describe()

"""## Estatísticas para dados coletivos:

### CONSUMO COLETIVO
"""

# Para 3 casas decimais
#pd.set_option('display.float_format', lambda x: '%.3f' % x)

# Calculando estatísticas descritivas

estagr_con_col = df_col.groupby('id_unidade_consumo')['V8000_deflacionado'].mean()
estagr_con_col

estagr_con_col.describe()

# para fazer:
# Provavelmente tenho que agrupar os dados por alguma variável e rever as estatísticas (P2)
# criar coluna da poupança = renda - consumo (P3)
# regressão ols renda x consumo (P3)

# Não consegui fazer
# como obter consumo/renda/poupança do modelo? (P1)
# comparação modelo x dados (P1)

# mod do modelo para incluir consumo de subsistência (P1)

# comparação mod_sub x dados. Se aproxima mais? (P2)
# transição do modelo (ler mais sobre) (P1)



df_ind